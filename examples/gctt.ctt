module gctt where

{-     Prerequisites
--------------------------- -}

-- From prelude:

Id (A : U) (a0 a1 : A) : U = IdP (<i> A) a0 a1

refl (A : U) (a : A) : Id A a a = <i> a

idfun (A : U) (a : A) : A = a

isoId (A B : U) (f : A -> B) (g : B -> A)
      (s : (y : B) -> Id B (f (g y)) y)
      (t : (x : A) -> Id A (g (f x)) x) : Id U A B =
      <i> glue B [ (i = 0) -> (A,f,g,s,t)
                 , (i = 1) -> (B,idfun B,idfun B,refl B,refl B) ]

-- From nat:

data nat = zero | suc (n : nat)

-- Unit type
data Unit = unit

-- The coproduct datatype:
-- A + B
data coprod (A B : U) =
    inl (a : A)
  | inr (b : B)
  
{-     Fixed point lemmata
------------------------------- -}

dfix' (A : U) (f : |> A -> A) : |> A
 = dfix k0 A f

fix' (A : U) (f : |> A -> A) : A
 = f (dfix' A f)

-- "later code"
later (A : |> U) : U
 = |> [A' <- A] A'

-- dfix *is* a fixed point operator
dfixeq (A : U) (f : |> A -> A) : Id (|> A) (dfix' A f) (next (f (dfix' A f)))
 = <i> dfix k0 A f [(i=1)]

fixeq (A : U) (f : |> A -> A) : Id A (fix' A f) (f (next (fix' A f)))
 = <i> f (dfixeq A f @ i)

-- folding and unfolding is needed when defining GR types as fixed points on
-- universes (isorecursive)

fold (f : |> U -> U) (A : |> (fix' U f)) : later (dfix' U f)
 = transport (<i> later (dfixeq U f @ -i)) A

unfold (f : |> U -> U) (A : later (dfix' U f)) : |> (fix' U f)
 = transport (<i> later (dfixeq U f @ i)) A

-- folding is an isomorphism:
unfoldfold (f : |> U -> U) (A : |> (fix' U f))
 : Id (|> (fix' U f)) A (unfold f (fold f A))
 = <i> comp (<j> q @ (i /\ -j))
       	    (comp (<j> q @ (i /\ j))
	    	  A
		  [(i=0) -> <_> A])
	    [(i=0) -> <_> A]
   where
     q : Id U (later (next (f (dfix' U f)))) (later (dfix' U f))
       = <i> later (dfixeq U f @ -i)

foldunfold (f : |> U -> U) (A : later (dfix' U f))
 : Id (later (dfix' U f)) A (fold f (unfold f A))
 = <i> comp (<j> q @ (-i \/ j))
       	    (comp (<j> q @ (-i \/ -j))
	    	  A
		  [(i=0) -> <_> A])
	    [(i=0) -> <_> A]
   where
     q : Id U (later (next (f (dfix' U f)))) (later (dfix' U f))
       = <i> later (dfixeq U f @ -i)

-- Thus the types are isomorphic, which by univalence (glueing, actually) means
-- that they are identical:

latercode (f : |> U -> U) : Id U (|> (fix' U f)) (later (dfix' U f))
 = isoId (|> (fix' U f))
   	 (later (dfix' U f))
	 (fold f)
	 (unfold f)
	 (\ (A : later (dfix' U f)) -> <i> foldunfold f A @ -i)
	 (\ (A : |> (fix' U f)) -> <i> unfoldfold f A @ -i)

-- But there is a much simpler proof (and it is actually used in the definition
-- of fold and unfold):

latercode' (f : |> U -> U) : Id U (|> (fix' U f)) (later (dfix' U f))
 = <i> later (dfixeq U f @ -i)


{-    Extensionality for later
------------------------------------ -}

-- We can show ▸(x=y) → (next x = next y):

nextext (A : U) (x y : A) (p : |> (Id A x y)) : Id (|> A) (next x) (next y)
 = <i> next [p' <- p] p' @ i

-- But the other direction, (next x = next y) → ▸(x=y), seems to be impossible.

{-
nextext' (A : U) (x y : A) (p : IdP (<_> |> A) (next x) (next y)) : |> (IdP (<_> A) x y)
 = next [x' <- p @ 0, y' <- p @ 1] ? 
-}

{-       Streams
------------------------- -}

-- We will define streams as guarded fixed points on universes. To keep things
-- simple, we will use streams of natural numbers, however things should work
-- out as well with polymorphic streams.

StrF (S : |> U) : U
 = (n : nat) * later S

Str : U
 = fix' U StrF

foldStr : |> Str -> later (dfix' U StrF)
 = fold StrF

unfoldStr : later (dfix' U StrF) -> |> Str
 = unfold StrF

hd (s : Str) : nat
 = s.1

tl (s : Str) : |> Str
 = unfoldStr s.2

Cons (n : nat) (s : |> Str) : Str
 = (n ,  foldStr s)

zeros : Str
 = fix k0 (Cons zero zeros)

-- Eta for streams. This is `pη` from gDTT paper:

etaStr (s1 s2 : Str)
       (hdp : Id nat (hd s1) (hd s2))
       (tlp : Id (|> Str) (tl s1) (tl s2))
       : Id Str s1 s2
 = <i> (hdp @ i, comp (<_> later (dfix' U StrF))
       	      	      (foldStr (tlp @ i))
		      [(i=0) -> <j> foldunfold StrF (s1.2) @ -j
		      ,(i=1) -> <j> foldunfold StrF (s2.2) @ -j])


etaStr' (s : Str) : IdP (<_> Str) s (Cons (hd s) (tl s))
 = <i> (s.1, foldunfold StrF s.2 @ i)

 
{-   Example:  zipWith preserves commutativity
---------------------------------------------------- -}

zipWith (f : nat -> nat -> nat) : Str -> Str -> Str
 = fix
   (\ (s1 s2 : Str) ->
      (Cons (f (hd s1) (hd s2))
      	    (next
	    	  [ zipWith' <- zipWith
		  , s1' <- tl s1
		  , s2' <- tl s2]
		  zipWith' s1' s2')))

-- It will be nice to be able to directly refer to the function which zipWith is
-- a fixed point of:

zwF (f : nat -> nat -> nat) (rec : |> (Str -> Str -> Str)) : Str -> Str -> Str
 = (\ (s1 s2 : Str) ->
      (Cons (f (hd s1) (hd s2))
      	    (next
	    	  [ zipWith' <- rec
		  , s1' <- tl s1
		  , s2' <- tl s2]
		  zipWith' s1' s2')))

zipWith' (f : nat -> nat -> nat) : Str -> Str -> Str
 = fix' (Str -> Str -> Str) (zwF f)


-- Commutativity
comm (f : nat -> nat -> nat) : U
 = (m n : nat) -> Id nat (f m n) (f n m)


zipWithPreservesComm (f : nat -> nat -> nat) (p : comm f)
 : (s1 s2 : Str) -> Id Str (zipWith f s1 s2) (zipWith f s2 s1)
 = fix
     (\ (s1 s2 : Str) ->
        (let
          q1 : Id (|> Str)
                  (next [s1' <- tl s1, s2' <- tl s2] (zipWith f s1' s2'))
                  (tl (zipWith f s1 s2))
             = <j> comp (<_> |> Str)
                        (next
                              [phi <- dfixeq (Str -> Str -> Str)
                                             (zwF f) @ -j
                              ,s1' <- tl s1
                              ,s2' <- tl s2]
                              (phi s1' s2'))
                        [(j=0) -> <_> (next [s1' <- tl s1, s2' <- tl s2] (zipWith f s1' s2'))
                        ,(j=1) -> <k> unfoldfold StrF
                                             (next
                                                   [phi <- dfix' (Str -> Str -> Str) (zwF f)
                                                   ,s1' <- tl s1
                                                   ,s2' <- tl s2]
                                                   (phi s1' s2'))  @ k]
          q2 : Id (|> Str)
                  (next [s1' <- tl s1, s2' <- tl s2] (zipWith f s2' s1'))
                  (tl (zipWith f s2 s1))
             = <j> comp (<_> |> Str)
                        (next
                              [phi <- dfixeq (Str -> Str -> Str)
                                             (zwF f) @ -j
                              ,s1' <- tl s1
                              ,s2' <- tl s2]
                              (phi s2' s1'))
                        [(j=0) -> <_> (next [s1' <- tl s1, s2' <- tl s2] (zipWith f s2' s1'))
                        ,(j=1) -> <k> unfoldfold StrF
                                             (next
                                                   [phi <- dfix' (Str -> Str -> Str) (zwF f)
                                                   ,s1' <- tl s1
                                                   ,s2' <- tl s2]
                                                   (phi s2' s1'))  @ k]
                                       
         in
          etaStr (zipWith f s1 s2)
                 (zipWith f s2 s1)
                 (p (hd s1) (hd s2))
                 (<i> comp (<_> |> Str)
                           (next [phi <- zipWithPreservesComm
                                    ,s1' <- tl s1
                                    ,s2' <- tl s2]
                                    phi s1' s2' @ i)
                           [(i=0) -> q1 
                           ,(i=1) -> q2])))



{-   Example: CoNats
  --------------------- -}

ConatF (rec : |> U) : U
  = coprod Unit (later rec)

Conat : U
  = fix' U ConatF

foldConat : |> Conat -> later (dfix' U ConatF)
  = fold ConatF

unfoldConat :  later (dfix' U ConatF) -> |> Conat
  = unfold ConatF

zero : Conat
  = inl unit
       
suc (n : |> Conat) : Conat
  = inr (foldConat n) 

omega : Conat                               
  = fix' Conat suc

{-     Example: Covectors                         
  ---------------------------- -}                                   

CovecR (rec : |> (Conat -> U)) : (n : Conat) -> U
  = split
      inl u -> Unit
      inr n -> (m : nat) * later (next [phi <- rec, n' <- unfoldConat n] (phi n'))

Covec : (n : Conat) -> U
  = fix' (Conat -> U) CovecR

-- foldCovec : ?

NilCV : Covec zero
 = unit

-- ConsCV (n : |> Conat) (m : nat) (v : |> [n' <- n] (Covec n')) : Covec (suc n)
--  = (m, ?)

-- onesR (rec : |> (Conat -> U)) : (n : Conat) -> Covec n
--   = split
--       inl u -> unit
--       inr n -> ConsCV ? ? ?
    
        
