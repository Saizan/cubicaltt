module gctt where

{-     Prerequisites
--------------------------- -}

-- From prelude:

Id (A : U) (a0 a1 : A) : U = IdP (<i> A) a0 a1

refl (A : U) (a : A) : Id A a a = <i> a

idfun (A : U) (a : A) : A = a

isoId (A B : U) (f : A -> B) (g : B -> A)
      (s : (y : B) -> Id B (f (g y)) y)
      (t : (x : A) -> Id A (g (f x)) x) : Id U A B =
      <i> glue B [ (i = 0) -> (A,f,g,s,t)
                 , (i = 1) -> (B,idfun B,idfun B,refl B,refl B) ]

mapOnPath (A B : U) (f : A -> B) (a b : A)
          (p : Id A a b) : Id B (f a) (f b) = <i> f (p @ i)

subst (A : U) (P : A -> U) (a b : A) (p : Id A a b) (e : P a) : P b =
  transport (mapOnPath A U P a b p) e

singl (A : U) (a : A) : U = (x : A) * Id A a x

contrSingl (A : U) (a b : A) (p : Id A a b) :
  Id (singl A a) (a,refl A a) (b,p) = <i> (p @ i,<j> p @ i/\j)

J (A : U) (a : A) (C : (x : A) -> Id A a x -> U)
  (d : C a (refl A a)) (x : A) (p : Id A a x) : C x p =
    subst (singl A a) T (a, refl A a) (x, p) (contrSingl A a x p) d
      where T (z : singl A a) : U = C (z.1) (z.2)

-- symmetry
inv (A : U) (a b : A) (p : Id A a b) : Id A b a = <i> p @ -i

-- transitivity of equality
trans (A : U) (a b c : A) (p : Id A a b) (q : Id A b c) : Id A a c =
  <i> comp (<_>A) (p @ i) [ (i = 1) -> q, (i=0) -> <_> a ]

-- some properties of equality of functions
ap (A B : U) (f : A -> B) (x y : A) (p : Id A x y): Id B (f x) (f y)
 = <i> f (p @ i)

fequal (A B : U) (f g : A -> B) (p : Id (A -> B) f g) (x : A) : Id B (f x) (g x)
 = <i> (p @ i) x

fequal2 (A B C : U) (f g : A -> B -> C) (p : Id (A -> B -> C) f g) (x : A) (y : B) : Id C (f x y) (g x y)
 = <i> (p @ i) x y

-- From nat:

data nat = Z | S (n : nat)

-- Unit type
data Unit = unit

-- The coproduct datatype:
-- A + B
data coprod (A B : U) =
    inl (a : A)
  | inr (b : B)
  
{-     Fixed point lemmata
------------------------------- -}

dfix' (A : U) (f : |> A -> A) : |> A
 = dfix k0 A f

fix' (A : U) (f : |> A -> A) : A
 = f (dfix' A f)

-- "later code"
later (A : |> U) : U
 = |> [A' <- A] A'

-- dfix *is* a fixed point operator
dfixeq (A : U) (f : |> A -> A) : Id (|> A) (dfix' A f) (next (f (dfix' A f)))
 = <i> dfix k0 A f [(i=1)]

fixeq (A : U) (f : |> A -> A) : Id A (fix' A f) (f (next (fix' A f)))
 = <i> f (dfixeq A f @ i)

-- folding and unfolding is needed when defining GR types as fixed points on
-- universes (isorecursive)

fold (f : |> U -> U) (A : |> (fix' U f)) : later (dfix' U f)
 = transport (<i> later (dfixeq U f @ -i)) A

unfold (f : |> U -> U) (A : later (dfix' U f)) : |> (fix' U f)
 = transport (<i> later (dfixeq U f @ i)) A

-- folding is an isomorphism:
unfoldfold (f : |> U -> U) (A : |> (fix' U f))
 : Id (|> (fix' U f)) A (unfold f (fold f A))
 = <i> comp (<j> q @ (i /\ -j))
       	    (comp (<j> q @ (i /\ j))
	    	  A
		  [(i=0) -> <_> A])
	    [(i=0) -> <_> A]
   where
     q : Id U (later (next (f (dfix' U f)))) (later (dfix' U f))
       = <i> later (dfixeq U f @ -i)

foldunfold (f : |> U -> U) (A : later (dfix' U f))
 : Id (later (dfix' U f)) A (fold f (unfold f A))
 = <i> comp (<j> q @ (-i \/ j))
       	    (comp (<j> q @ (-i \/ -j))
	    	  A
		  [(i=0) -> <_> A])
	    [(i=0) -> <_> A]
   where
     q : Id U (later (next (f (dfix' U f)))) (later (dfix' U f))
       = <i> later (dfixeq U f @ -i)

-- Thus the types are isomorphic, which by univalence (glueing, actually) means
-- that they are identical:

latercode (f : |> U -> U) : Id U (|> (fix' U f)) (later (dfix' U f))
 = isoId (|> (fix' U f))
   	 (later (dfix' U f))
	 (fold f)
	 (unfold f)
	 (\ (A : later (dfix' U f)) -> <i> foldunfold f A @ -i)
	 (\ (A : |> (fix' U f)) -> <i> unfoldfold f A @ -i)

-- But there is a much simpler proof (and it is actually used in the definition
-- of fold and unfold):

latercode' (f : |> U -> U) : Id U (|> (fix' U f)) (later (dfix' U f))
 = <i> later (dfixeq U f @ -i)


{-    Extensionality for later
------------------------------------ -}

-- We can show ▸(a=b) → (next a = next b):

nextext (A : U) (a b : A) (p : |> (Id A a b)) : Id (|> A) (next a) (next b)
 = <i> next [p' <- p] p' @ i

-- Using J we can show the opposite direction: (next a = next b) → ▸(a=b)


nextext' (A : U) (a b : A) (p : IdP (<_> |> A) (next a) (next b)) : |> (Id A a b)
 = J  (|> A) 
      (next a)
      (\ (x : |> A) (_ : Id (|> A) (next a) x) -> |> [x' <- x] (Id A a x'))
      (next (refl A a))
      (next b)
      p

{-       Streams
------------------------- -}

-- We will define streams as guarded fixed points on universes. To keep things
-- simple, we will use streams of natural numbers, however things should work
-- out as well with polymorphic streams.

StrF (S : |> U) : U
 = (n : nat) * later S

Str : U
 = fix' U StrF

foldStr : |> Str -> later (dfix' U StrF)
 = fold StrF

unfoldStr : later (dfix' U StrF) -> |> Str
 = unfold StrF



hd (s : Str) : nat
 = s.1

tl (s : Str) : |> Str
 = unfoldStr s.2

Cons (n : nat) (s : |> Str) : Str
 = (n ,  foldStr s)

zeros : Str
 = fix (Cons Z zeros)

-- Eta for streams. This is `pη` from gDTT paper:

etaStr (s1 s2 : Str)
       (hdp : Id nat (hd s1) (hd s2))
       (tlp : Id (|> Str) (tl s1) (tl s2))
       : Id Str s1 s2
 = <i> (hdp @ i, comp (<_> later (dfix U StrF))
       	      	      (foldStr (tlp @ i))
		      [(i=0) -> <j> foldunfold StrF (s1.2) @ -j
		      ,(i=1) -> <j> foldunfold StrF (s2.2) @ -j])


etaStr' (s : Str) : IdP (<_> Str) s (Cons (hd s) (tl s))
 = <i> (s.1, foldunfold StrF s.2 @ i)

 
{-   Example:  zipWith preserves commutativity
---------------------------------------------------- -}
-- It will be nice to be able to directly refer to the function which zipWith is
-- a fixed point of:

zwF (f : nat -> nat -> nat) (rec : |> (Str -> Str -> Str)) : Str -> Str -> Str
 = (\ (s1 s2 : Str) ->
      (Cons (f (hd s1) (hd s2))
      	    (next
	    	  [ zipWith' <- rec
		  , s1' <- tl s1
		  , s2' <- tl s2]
		  zipWith' s1' s2')))

zipWith (f : nat -> nat -> nat) : Str -> Str -> Str
 = fix' (Str -> Str -> Str) (zwF f)

zwFunfold (f : nat -> nat -> nat) : Id (Str -> Str -> Str) (zipWith f) (zwF f (next (zipWith f)))
  = fixeq (Str -> Str -> Str) (zwF f)


-- the unfolding lemma for the zipWith. Morally,
-- zipWith f xs ys = Cons (f (hd xs) (hd ys)) (next (zipWith f) ⊛ (tl xs) ⊛ (tl ys))
zipWithUnfold (f : nat -> nat -> nat) (xs ys : Str) : 
    Id Str (zipWith f xs ys) 
           (Cons (f (hd xs) (hd ys)) (next [xs <- tl xs, ys <- tl ys] (zipWith f xs ys)))
 = fequal2 Str Str Str (zipWith f) 
                       (zwF f (next (fix' (Str -> Str -> Str) (zwF f))))
                       (zwFunfold f) xs ys


zipWithEq (f : nat -> nat -> nat)
 : Id (Str -> Str -> Str)
      (zwF f (next (zipWith f)))
      (zipWith f)
 = <i> fixeq (Str -> Str -> Str) (zwF f) @ -i


-- Commutativity property
comm (f : nat -> nat -> nat) : U
 = (m n : nat) -> Id nat (f m n) (f n m)

-- zipWith preserves commutativity. The largest part of the proof term, q1 and
-- q2, simply show that the tail of an application of zipWith is equal to its
-- unfolding. It must be possible to state this succintly with some of the above
-- lemmata.
zipWithPreservesComm (f : nat -> nat -> nat) (p : comm f)
 : (s1 s2 : Str) -> Id Str (zipWith f s1 s2) (zipWith f s2 s1)
 = fix
     (\ (s1 s2 : Str) ->
        (let
          q1 : Id (|> Str)
                  (next [s1' <- tl s1, s2' <- tl s2] (zipWith f s1' s2'))
                  (tl (zipWith f s1 s2))
             = -- <j> tl (zipWithEq f @ j s1 s2)
               <j> comp (<_> |> Str)
                        (next
                              [phi <- dfixeq (Str -> Str -> Str)
                                             (zwF f) @ -j
                              ,s1' <- tl s1
                              ,s2' <- tl s2]
                              (phi s1' s2'))
                        [(j=0) -> <_> (next [s1' <- tl s1, s2' <- tl s2] (zipWith f s1' s2'))
                        ,(j=1) -> <k> unfoldfold StrF
                                             (next
                                                   [phi <- dfix' (Str -> Str -> Str) (zwF f)
                                                   ,s1' <- tl s1
                                                   ,s2' <- tl s2]
                                                   (phi s1' s2'))  @ k]
          q2 : Id (|> Str)
                  (next [s1' <- tl s1, s2' <- tl s2] (zipWith f s2' s1'))
                  (tl (zipWith f s2 s1))
             = <j> comp (<_> |> Str)
                        (next
                              [phi <- dfixeq (Str -> Str -> Str)
                                             (zwF f) @ -j
                              ,s1' <- tl s1
                              ,s2' <- tl s2]
                              (phi s2' s1'))
                        [(j=0) -> <_> (next [s1' <- tl s1, s2' <- tl s2] (zipWith f s2' s1'))
                        ,(j=1) -> <k> unfoldfold StrF
                                             (next
                                                   [phi <- dfix' (Str -> Str -> Str) (zwF f)
                                                   ,s1' <- tl s1
                                                   ,s2' <- tl s2]
                                                   (phi s2' s1'))  @ k]
                                       
         in
          etaStr (zipWith f s1 s2)
                 (zipWith f s2 s1)
                 (p (hd s1) (hd s2))
                 (<i> comp (<_> |> Str)
                           (next [phi <- zipWithPreservesComm
                                    ,s1' <- tl s1
                                    ,s2' <- tl s2]
                                    phi s1' s2' @ i)
                           [(i=0) -> q1
                           ,(i=1) -> q2])))

{-   Example: CoNats
  --------------------- -}

ConatF (rec : |> U) : U
  = coprod Unit (later rec)

Conat : U
  = fix' U ConatF

foldConat : |> Conat -> later (dfix' U ConatF)
  = fold ConatF

unfoldConat :  later (dfix' U ConatF) -> |> Conat
  = unfold ConatF

zero : Conat
  = inl unit
       
suc (n : |> Conat) : Conat
  = inr (foldConat n) 

omega : Conat                               
  = fix' Conat suc

{-     Example: Covectors                         
  ---------------------------- -}                                   

CovecR (rec : |> (Conat -> U)) : (n : Conat) -> U
  = split
      inl u -> Unit
      inr n -> (m : nat) * later (next [phi <- rec, n' <- unfoldConat n] (phi n'))

Covec : (n : Conat) -> U
  = fix' (Conat -> U) CovecR

coVecEqO : Id U (Covec (inl unit)) Unit
  = <i> Unit

coVecUnfold (n : |> Conat) : Id U (Covec (suc n)) (CovecR (next Covec) (suc n))
  = fequal Conat U Covec (CovecR (next Covec)) (fixeq (Conat -> U) CovecR) (suc n)

coVecEqSAux (n : |> Conat) : Id U ((_ : nat) * (later (next [n' <- unfoldConat (foldConat n)] (Covec n'))))
                                  ((_ : nat) * (later (next [n' <- n] (Covec n'))))
 = subst (|> Conat)
         (\ (x : |> Conat) -> (Id U ((_ : nat) * (later (next [n' <- unfoldConat (foldConat n)] (Covec n')))) ((_ : nat) * (later (next [n' <- x] (Covec n'))))))
         (unfoldConat (foldConat n))
         n
         (inv (|> Conat) n (unfoldConat (foldConat n)) (unfoldfold ConatF n))
         (refl U ((_ : nat) * (later (next [n' <- unfoldConat (foldConat n)] (Covec n')))))

coVecEqS (n : |> Conat) : Id U (Covec (suc n)) ((_ : nat) * (later (next [n' <- n] (Covec n'))))
  = trans U
          (Covec (suc n))
          ((_ : nat) * (later (next [n' <- unfoldConat (foldConat n)] (Covec n'))))
          ((_ : nat) * (later (next [n' <- n] (Covec n'))))
          (coVecUnfold n)
          (coVecEqSAux n)

-- and as a corollary we have the following nice equation
coVecEqSnext (n : Conat) : Id U (Covec (suc (next n))) ((_ : nat) * (later (next (Covec n))))
  = coVecEqS (next n)

NilCV : Covec zero
 = unit

unfoldCovecInrEq (m : later (dfix' U ConatF)) : Id U (Covec (inr m)) ((_ : nat) * (later (next [n' <- unfoldConat m] (Covec n'))))
  = fequal Conat U Covec (CovecR (next Covec)) (fixeq (Conat -> U) CovecR) (inr m)

unfoldCovecInr (m : later (dfix' U ConatF)) (xs : Covec (inr m)) : (_ : nat) * (later (next [n' <- unfoldConat m] (Covec n')))
  = transport (unfoldCovecInrEq m) xs

foldCovecInr (m : later (dfix' U ConatF)) (xs : (_ : nat) * (later (next [n' <- unfoldConat m] (Covec n')))) : Covec (inr m)
  = transport (inv U (Covec (inr m)) ((_ : nat) * (later (next [n' <- unfoldConat m] (Covec n')))) (unfoldCovecInrEq m)) xs


ConsCV (n : later (dfix' U ConatF)) (x : nat) (xs : |> [n' <- unfoldConat n] (Covec n')): Covec (inr n)
 = foldCovecInr n (x, xs)

headCV (n : later (dfix' U ConatF)) (xs : Covec (inr n)) : nat
  = xs.1

tailCV (n : later (dfix' U ConatF)) (xs : Covec (inr n)) : later (next [n' <- unfoldConat n] (Covec n'))
  = (unfoldCovecInr n xs).2

-- map function on covectors.
-- First the functional for defining it.
mapCVF (f : nat -> nat) (rec : |> ((n : Conat) -> Covec n -> Covec n)) : (n : Conat) -> Covec n -> Covec n
  = split
      inl u -> \ (xs : Unit) -> xs
      inr m -> \ (xs : Covec (inr m)) -> ConsCV m (f (headCV m xs)) (next [rec' <- rec, m' <- unfoldConat m, xs' <- (tailCV m xs)] (rec' m' xs'))

-- The map function on covectors.
mapCV (f : nat -> nat) : (n : Conat) -> Covec n -> Covec n
  = fix (mapCVF f mapCV)

onesR (rec : |> ((n : Conat) -> Covec n)) : (n : Conat) -> Covec n
  = split
      inl u -> unit
      inr m -> ConsCV m (S Z) (next [rec' <- rec, m' <- unfoldConat m] (rec' m'))

onesCV : (n : Conat) -> Covec n
  = fix (onesR onesCV)
  

{-  Miscellaneous properties of `next` and identity type.
  --------------------------------------------------------- -}

nextlater (A : U) (a b : A) (p : Id (|> A) (next a) (next b)) : |> (Id A a b)
  = J (|> A) 
      (next a)
      (\ (x : |> A) (_ : Id (|> A) (next a) x) -> |> [x' <- x] (Id A a x'))
      (next (refl A a))
      (next b)
      p

nextlaterxi1 (A : U) (B : A -> U) (a : |> A) (t s : (x : A) -> B x) 
             (p : Id (|> [x <- a] (B x)) (next [x <- a] (t x)) (next [x <- a] (s x))) : 
             |> [x <- a] (Id (B x) (t x) (s x))
  = J (|> [x <- a] (B x))
      (next [x <- a] (t x))
      (\ (y : |> [x <- a] (B x)) 
         (_ : Id (|> [x <- a] (B x)) (next [x <- a] (t x)) y) -> 
         |> [x <- a, y' <- y] (Id (B x) (t x) y'))
      (next [x <- a] (refl (B x) (t x)))
      (next [x <- a] (s x))
      p

-- there is a pattern, of course. So I conjecture that this works for any ξ. But
-- I don't think this can be stated in the type theory, since delayed
-- subsitutions are not a first-class citizen.
nextlaterxi2 (A : U) (B : A -> U) (C : (x : A) -> B x -> U)
             (a : |> A)
             (b : |> [x <- a] (B x))
             (t s : (x : A) -> (y : B x) -> C x y)
             (p : Id (|> [x <- a, y <- b] (C x y)) (next [x <- a, y <- b] (t x y)) (next [x <- a, y <- b] (s x y))) : 
             |> [x <- a, y <- b] (Id (C x y) (t x y) (s x y))
  = J (|> [x <- a, y <- b] (C x y))
      (next [x <- a, y <- b] (t x y))
      (\ (z : |> [x <- a, y <- b] (C x y)) 
         (_ : Id (|> [x <- a, y <- b] (C x y)) (next [x <- a, y <- b] (t x y)) z) -> 
         |> [x <- a, y <- b, z' <- z] (Id (C x y) (t x y) z'))
      (next [x <- a, y <- b] (refl (C x y) (t x y)))
      (next [x <- a, y <- b] (s x y))
      p

-- part of the fact that next is a congruence. Follows directly from the substitution lemma.
nexteq (A B : U) (a b : |> A) (t : A -> B) (p : Id (|> A) a b) : Id (|> B) (next [x <- a] (t x)) (next [x <- b] (t x))
 = subst (|> A)
         (\ (y : |> A) -> Id (|> B) (next [x <- a] (t x)) (next [x <- y] (t x)))
         a
         b
         p
         (refl (|> B) (next [x <- a] (t x)))


nexteta (A : U) (a : |> A) : Id (|> A) a (next [x <- a] x)
  = <i> a

nexteta2 (A : U) (a b : |> A) : Id (|> A) a (next [x <- a, y <- b] x)
  = <i> a


nexteta2' (A : U) (a b : |> A) : Id (|> A) (next [x <- a, y <- b] x) a
  = <i> a

-- It is saying that delayed substitutions preserve equality. As a special case,
-- we should be able to prove equalities like a = b -> f ⊛ a = f ⊛ b.
laterid (A : U) (a b : |> A) (p : Id (|> A) a b): |> [x' <- a, y' <- b] (Id A x' y')
  = nextlaterxi2 A
                 (\ (_ : A) -> A)
                 (\ (x : A) (_ : A) -> A)
                 a
                 b
                 (\ (x : A) (y : A) -> x)
                 (\ (x : A) (y : A) -> y)
                 (trans (|> A) 
                        (next [x <- a, y <- b] x)
                        a 
                        (next [x <- a, y <- b] y) 
                        (nexteta2' A a b) 
                        (trans (|> A)
                               a 
                               b
                               (next [x <- a, y <- b] y)
                               p
                               (nexteta2 A b a)))

-- Without nexteta we can prove the following weaker property where we assume a and b are of the form next.
lateridweak (A : U) (a b : A) (p : Id (|> A) (next a) (next b)): |> (Id A a b)
  = nextlaterxi2 A
                 (\ (_ : A) -> A)
                 (\ (x : A) (_ : A) -> A)
                 (next a)
                 (next b)
                 (\ (x : A) (y : A) -> x)
                 (\ (x : A) (y : A) -> y)
                 p

-- TODO: Are lateridweak and nextext inverses to each other (up to propositional equality).

idnext (A : U) (a b : |> A) (p : |> [x' <- a, y' <- b] (Id A x' y')) : Id (|> A) (next [x' <- a] x') (next [x' <- b] x')
  = <i> next [p' <- p] (p' @ i)


