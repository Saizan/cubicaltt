module gctt where

{-     Prerequisites
--------------------------- -}

-- From prelude:

Id (A : U) (a0 a1 : A) : U = IdP (<i> A) a0 a1

refl (A : U) (a : A) : Id A a a = <i> a

idfun (A : U) (a : A) : A = a

isoId (A B : U) (f : A -> B) (g : B -> A)
      (s : (y : B) -> Id B (f (g y)) y)
      (t : (x : A) -> Id A (g (f x)) x) : Id U A B =
      <i> glue B [ (i = 0) -> (A,f,g,s,t)
                 , (i = 1) -> (B,idfun B,idfun B,refl B,refl B) ]

-- From nat:

data nat = zero | suc (n : nat)


{-     Fixed point lemmata
------------------------------- -}

dfix' (A : U) (f : |> k0 A -> A) : |> k0 A
 = dfix k0 A f

fix' (A : U) (f : |> k0 A -> A) : A
 = f (dfix' A f)

-- "later code"
later (A : |> k0 U) : U
 = |> k0 [A' <- A] A'

-- dfix *is* a fixed point operator
dfixeq (A : U) (f : |> k0 A -> A) : Id (|> k0 A) (dfix' A f) (next k0 (f (dfix' A f)))
 = <i> dfix k0 A f [(i=1)]

fixeq (A : U) (f : |> k0 A -> A) : Id A (fix' A f) (f (next k0 (fix' A f)))
 = <i> f (dfixeq A f @ i)

-- folding and unfolding is needed when defining GR types as fixed points on
-- universes (isorecursive)

fold (f : |> k0 U -> U) (A : |> k0 (fix' U f)) : later (dfix' U f)
 = transport (<i> later (dfixeq U f @ -i)) A

unfold (f : |> k0 U -> U) (A : later (dfix' U f)) : |> k0 (fix' U f)
 = transport (<i> later (dfixeq U f @ i)) A

-- folding is an isomorphism:
unfoldfold (f : |> k0 U -> U) (A : |> k0 (fix' U f))
 : Id (|> k0 (fix' U f)) A (unfold f (fold f A))
 = <i> comp (<j> q @ (i /\ -j))
       	    (comp (<j> q @ (i /\ j))
	    	  A
		  [(i=0) -> <_> A])
	    [(i=0) -> <_> A]
   where
     q : Id U (later (next k0 (f (dfix' U f)))) (later (dfix' U f))
       = <i> later (dfixeq U f @ -i)

foldunfold (f : |> k0 U -> U) (A : later (dfix' U f))
 : Id (later (dfix' U f)) A (fold f (unfold f A))
 = <i> comp (<j> q @ (-i \/ j))
       	    (comp (<j> q @ (-i \/ -j))
	    	  A
		  [(i=0) -> <_> A])
	    [(i=0) -> <_> A]
   where
     q : Id U (later (next k0 (f (dfix' U f)))) (later (dfix' U f))
       = <i> later (dfixeq U f @ -i)

-- Thus the types are isomorphic, which by univalence (glueing, actually) means
-- that they are identical:

latercode (f : |> k0 U -> U) : Id U (|> k0 (fix' U f)) (later (dfix' U f))
 = isoId (|> k0 (fix' U f))
   	 (later (dfix' U f))
	 (fold f)
	 (unfold f)
	 (\ (A : later (dfix' U f)) -> <i> foldunfold f A @ -i)
	 (\ (A : |> k0 (fix' U f)) -> <i> unfoldfold f A @ -i)

-- But there is a much simpler proof (and it is actually used in the definition
-- of fold and unfold):

latercode' (f : |> k0 U -> U) : Id U (|> k0 (fix' U f)) (later (dfix' U f))
 = <i> later (dfixeq U f @ -i)


{-    Extensionality for later
------------------------------------ -}

-- We can show ▸(x=y) → (next x = next y):

nextext (A : U) (x y : A) (p : |> k0 (Id A x y)) : Id (|> k0 A) (next k0 x) (next k0 y)
 = <i> next k0 [p' <- p] p' @ i

-- But the other direction, (next x = next y) → ▸(x=y), seems to be impossible.

{-
nextext' (A : U) (x y : A) (p : IdP (<_> |> k0 A) (next k0 x) (next k0 y)) : |> k0 (IdP (<_> A) x y)
 = next k0 [x' <- p @ 0, y' <- p @ 1] ? 
-}

{-       Streams
------------------------- -}

-- We will define streams as guarded fixed points on universes. To keep things
-- simple, we will use streams of natural numbers, however things should work
-- out as well with polymorphic streams.

StrF (S : |> k0 U) : U
 = (n : nat) * later S

Str : U
 = fix' U StrF

foldStr : |> k0 Str -> later (dfix' U StrF)
 = fold StrF

unfoldStr : later (dfix' U StrF) -> |> k0 Str
 = unfold StrF

hd (s : Str) : nat
 = s.1

tl (s : Str) : |> k0 Str
 = unfoldStr s.2

Cons (n : nat) (s : |> k0 Str) : Str
 = (n ,  foldStr s)

zeros : Str
 = fix k0 (Cons zero zeros)

-- Eta for streams. This is `pη` from gDTT paper:

etaStr (s1 s2 : Str)
       (hdp : Id nat (hd s1) (hd s2))
       (tlp : Id (|> k0 Str) (tl s1) (tl s2))
       : Id Str s1 s2
 = <i> (hdp @ i, comp (<_> later (dfix' U StrF))
       	      	      (foldStr (tlp @ i))
		      [(i=0) -> <j> foldunfold StrF (s1.2) @ -j
		      ,(i=1) -> <j> foldunfold StrF (s2.2) @ -j])


etaStr' (s : Str) : IdP (<_> Str) s (Cons (hd s) (tl s))
 = <i> (s.1, foldunfold StrF s.2 @ i)

 
{-   Example:  zipWith preserves commutativity
---------------------------------------------------- -}

zipWith (f : nat -> nat -> nat) : Str -> Str -> Str
 = fix k0
   (\ (s1 s2 : Str) ->
      (Cons (f (hd s1) (hd s2))
      	    (next k0
	    	  [ zipWith' <- zipWith
		  , s1' <- tl s1
		  , s2' <- tl s2]
		  zipWith' s1' s2')))

-- It will be nice to be able to directly refer to the function which zipWith is
-- a fixed point of:

zwF (f : nat -> nat -> nat) (rec : |> k0 (Str -> Str -> Str)) : Str -> Str -> Str
 = (\ (s1 s2 : Str) ->
      (Cons (f (hd s1) (hd s2))
      	    (next k0
	    	  [ zipWith' <- rec
		  , s1' <- tl s1
		  , s2' <- tl s2]
		  zipWith' s1' s2')))

zipWith' (f : nat -> nat -> nat) : Str -> Str -> Str
 = fix' (Str -> Str -> Str) (zwF f)


-- Commutativity
comm (f : nat -> nat -> nat) : U
 = (m n : nat) -> Id nat (f m n) (f n m)


zipWithPreservesComm (f : nat -> nat -> nat) (p : comm f)
 : (s1 s2 : Str) -> Id Str (zipWith f s1 s2) (zipWith f s2 s1)
 = fix k0
     (\ (s1 s2 : Str) ->
        (let
          q1 : Id (|> k0 Str)
                  (next k0 [s1' <- tl s1, s2' <- tl s2] (zipWith f s1' s2'))
                  (tl (zipWith f s1 s2))
             = <j> comp (<_> |> k0 Str)
                        (next k0
                              [phi <- dfixeq (Str -> Str -> Str)
                                             (zwF f) @ -j
                              ,s1' <- tl s1
                              ,s2' <- tl s2]
                              (phi s1' s2'))
                        [(j=0) -> <_> (next k0 [s1' <- tl s1, s2' <- tl s2] (zipWith f s1' s2'))
                        ,(j=1) -> <k> unfoldfold StrF
                                             (next k0
                                                   [phi <- dfix' (Str -> Str -> Str) (zwF f)
                                                   ,s1' <- tl s1
                                                   ,s2' <- tl s2]
                                                   (phi s1' s2'))  @ k]
          q2 : Id (|> k0 Str)
                  (next k0 [s1' <- tl s1, s2' <- tl s2] (zipWith f s2' s1'))
                  (tl (zipWith f s2 s1))
             = <j> comp (<_> |> k0 Str)
                        (next k0
                              [phi <- dfixeq (Str -> Str -> Str)
                                             (zwF f) @ -j
                              ,s1' <- tl s1
                              ,s2' <- tl s2]
                              (phi s2' s1'))
                        [(j=0) -> <_> (next k0 [s1' <- tl s1, s2' <- tl s2] (zipWith f s2' s1'))
                        ,(j=1) -> <k> unfoldfold StrF
                                             (next k0
                                                   [phi <- dfix' (Str -> Str -> Str) (zwF f)
                                                   ,s1' <- tl s1
                                                   ,s2' <- tl s2]
                                                   (phi s2' s1'))  @ k]
                                       
         in
          etaStr (zipWith f s1 s2)
                 (zipWith f s2 s1)
                 (p (hd s1) (hd s2))
                 (<i> comp (<_> |> k0 Str)
                           (next k0 [phi <- zipWithPreservesComm
                                    ,s1' <- tl s1
                                    ,s2' <- tl s2]
                                    phi s1' s2' @ i)
                           [(i=0) -> q1 
                           ,(i=1) -> q2])))
