module gctt_later_and_inh where

-- Note: This file should really be in gctt-experiments/ but needs results from
-- examples/equiv.ctt

import equiv


-- All involutions are equivalences
involIsEquiv (A : U) (f : A -> A) (invol : (x : A) -> Id A (f (f x)) x)
    : isEquiv A A f = gradLemma A A f f invol invol

IdP_transp (A B : U) (p : Id U A B) (x : A) (y : B) (q : IdP p x y) :
    Id B (comp p x []) y = <i> comp p x [ (i = 1) -> q ]

-- If f : A -> B is an equivalence, then there is a path between x and f x over
-- the path Id U A B that f generates via gluing.
IdP_equivId (A B : U) (f : A -> B) (p : isEquiv A B f) (x : A) :
    IdP (equivId A B f p) x (f x) =
    <i> glueElem (f x) [ (i = 0) -> x, (i = 1) -> f x ]

-- If f : A -> A is a self-equivalence without fixpoints, then no element of A
-- has a self-path over the self-path for A generated by f via gluing.
noFix_noSelfIdP (A : U) (f : A -> A) (p : isEquiv A A f)
    (noFix : (x : A) -> neg (Id A x (f x))) (x : A)
    (selfIdP : IdP (equivId A A f p) x x) : N0 =
    noFix x (<i> comp (equivId A A f p) x
                [ (i = 0) -> selfIdP, (i = 1) -> IdP_equivId A A f p x ])

-- For any P : U -> U, if there is a type X that has a self-path over which
-- there is no self-path and such that P X is contractible, then it is absurd
-- that (A : U) -> P A -> A. This generalizes Lemma 3.2.2 and Exercise 3.11
-- from the HoTT book.
-- TODO: find a better name
--      current one: P A is a prop. that is logically equivalent to A -> absurd
noPropEquiv (X : U) (p : Id U X X) (noSelfIdP : (x : X) -> neg (IdP p x x))
    (P : U -> U) (ctr : isContr (P X)) (fromP : (A : U) -> P A -> A) : N0 = let
    -- Apply "pointwise" fromP(p) to the filling from ctr.1 to its transport
    -- along P(p).
    IdP_img_comp : IdP p (fromP X ctr.1) (fromP X (comp (<j> P (p @ j)) ctr.1 [])) =
        <i> fromP (p @ i) (comp (<j> P (p @ (i /\ j))) ctr.1 [ (i = 0) -> <_> ctr.1 ])
    -- The transport can be contracted back (in P X) to the center, leading to
    -- a self-path over p.
    selfIdP_img : IdP p (fromP X ctr.1) (fromP X ctr.1) =
        <i> comp (<_> p @ i) (IdP_img_comp @ i)
            [ (i = 0) -> <_> fromP X ctr.1
            , (i = 1) -> <j> fromP X (ctr.2 (comp (<j> P (p @ j)) ctr.1 []) @ -j) ]
    in noSelfIdP (fromP X ctr.1) selfIdP_img
-- Further generalisation:
-- Conditions on F : U -> U such that ((A : U) -> F (inh A) -> F A) -> F N0?
--      true for F = idfun U, F = const U X (X inhabited)
--      false if F = inh, F = const U N0
--      what about F = |>?


-- Booleans
data bool = true | false

-- Canonical interpretation of booleans as a proposition
asProp : bool -> U = split
    true  -> Unit
    false -> N0

-- The boolean negation
negb : bool -> bool = split
    true -> false
    false -> true

-- Negation has no fixpoints
negbNoFix : (b : bool) -> neg (Id bool b (negb b)) = split
    true  -> \(p : Id bool true false) -> comp (<i> asProp (p @  i)) tt []
    false -> \(p : Id bool false true) -> comp (<i> asProp (p @ -i)) tt []

-- Negation is involutive
negbInvol : (b : bool) -> Id bool (negb (negb b)) b = split
    true  -> <_>  true
    false -> <_> false

-- Negation is an equivalence
negbIsEquiv : isEquiv bool bool negb = involIsEquiv bool negb negbInvol

-- Non-trivial self-path for booleans
negbId : Id U bool bool = equivId bool bool negb negbIsEquiv

-- There is no self-path over negbId
negbNoSelfIdP : (b : bool) -> neg (IdP negbId b b) =
    noFix_noSelfIdP bool negb negbIsEquiv negbNoFix

-- The canonical counter-example for noPropEquiv is bool with negbId. (And P A
-- is a proposition implied by A for all A : U).
noPropEquivBool : (P : U -> U) -> isContr (P bool) -> neg ((A : U) -> P A -> A)
    = noPropEquiv bool negbId negbNoSelfIdP

-- Lemma 3.2.2 from the HoTT book. Here P is double negation.
HoTT_lemma_3_2_2 : neg ((A : U) -> neg (neg A) -> A) =
    noPropEquivBool (\(A : U) -> neg (neg A))
        (dNeg bool true, propNeg (neg bool) (dNeg bool true))


-- Propositional truncation, i.e. proposition witnessing the inhabitedness of a
-- type.
data inh (A : U)
    = inc (a : A)
    | squash (x y : inh A) <i> [(i = 0) -> x, (i = 1) -> y]

-- Truncation is a proposition
inhIsProp (A : U) : prop (inh A) = \(x y : inh A) ->
    <i> squash{inh A} x y @ i

-- Recursion principle: if A implies a proposition B then inh A implies B.
inhRec (A B : U) (pP : prop B) (f : A -> B) : inh A -> B = split
    inc a -> f a
    squash x y @ i -> pP (inhRec A B pP f x) (inhRec A B pP f y) @ i

-- Induction principle
inhElim (A : U) (B : (inh A) -> U) (pP : (x : inh A) -> prop (B x))
        (f : (a : A) -> B (inc a)) : (x : inh A) -> B x = split
    inc a -> f a
    squash x y @ i -> lemPropF (inh A) B pP x y (inhIsProp A x y)
                        (inhElim A B pP f x) (inhElim A B pP f y) @ i

-- Functorial action
inhMap (A B : U) (f : A -> B) : inh A -> inh B =
    inhRec A (inh B) (inhIsProp B) (\(x : A) -> inc (f x))

-- Exercise 3.11 from the HoTT book. Here P is truncation.
HoTT_exercise_3_11 : neg ((A : U) -> inh A -> A) =
    noPropEquivBool inh (inc true, inhIsProp bool (inc true))


laterPi_PiLater (A : U) (B : A -> U) (f' : |> ((x : A) -> B x))
    (x' : |> A) : |> [x <- x'] B x = next [f <- f', x <- x'] f x

laterId_IdLater (A B : U) (p : Id U A B) (x : A) (y : B)
    (q' : |> (IdP p x y)) : IdP (<i> |> p @ i) (next x) (next y) =
    <i> next [q <- q'] q @ i

IdLater_laterId (A B : U) (p : Id U A B) (x' : |> A) (y' : |> B)
    (q : IdP (<i> |> p @ i) x' y') : |> [x <- x', y <- y'] (IdP p x y) = let
    base : |> [x <- x'] (Id A x x) = next [x <- x'] (<_> x)
    in comp (<j> |> [x <- x', y <- q @ j] (IdP (<i> p @ (i /\ j)) x y)) base []

-- If A is a proposition, then so is |> A.
laterIsProp (A : U) (p : prop A) : prop (|> A) = \(x' y' : |> A) ->
    <i> next [x <- x', y <- y'] p x y @ i

-- Later can be "pulled out" a truncation.
inhLater_laterInh (A : U) : inh (|> A) -> |> (inh A) =
    inhRec (|> A) (|> (inh A)) (laterIsProp (inh A) (inhIsProp A))
        (\ (x' : |> A) -> next [x <- x'] inc x)

-- This is just noPropEquiv with |> and next added.
noPropLater (X : U) (p : Id U X X) (noSelfIdP : (x : X) -> neg (IdP p x x))
    (P : U -> U) (ctr : isContr (P X)) (fromP : (A : U) -> |> (P A) -> |> A) :
    |> N0 = let
        center : |> (P X) = next ctr.1
        center' : |> (P X) = next comp (<j> P (p @ j)) ctr.1 []
        IdP_img_comp : IdP (<i> |> (p @ i)) (fromP X center) (fromP X center') =
            <i> fromP (p @ i) (next comp (<j> P (p @ (i /\ j))) ctr.1 [ (i = 0) -> <_> ctr.1 ])
        selfIdP_img : IdP (<i> |> (p @ i)) (fromP X center) (fromP X center) =
            <i> comp (<_> |> (p @ i)) (IdP_img_comp @ i)
                [ (i = 0) -> <_> fromP X center
                , (i = 1) -> <j> fromP X (next ctr.2 (comp (<j> P (p @ j)) ctr.1 []) @ -j) ]
        later_selfIdP : |> [x <- fromP X center] IdP p x x =
            IdLater_laterId X X p (fromP X center) (fromP X center) selfIdP_img
        in next [x <- fromP X center, q <- later_selfIdP] noSelfIdP x q

-- The canonical counter-example for noPropLater is also bool with negbId.
noPropEquivBool : (P : U -> U) -> isContr (P bool) ->
    ((A : U) -> |> (P A) -> |> A) -> |> N0
    = noPropLater bool negbId negbNoSelfIdP

-- If later can be "pushed in" a truncation, then in fact |> (inh A) -> |> A.
-- If this is possible for all A : U, then |> N0 can be deduced.
HoTT_exercise_3_11_later : ((A : U) -> |> (inh A) -> |> A) -> |> N0 =
    noPropEquivBool inh (inc true, inhIsProp bool (inc true))


-- Attempts to prove Theorem 2.7 (4) from [1].
-- [1] Lars Birkedal, Rasmus Ejlers Møgelberg, Jan Schwinghammer, and Kristian
-- Støvring. First steps in synthetic guarded domain theory: step-indexing in
-- the topos of trees. LMCS, 8(4), 2012.

-- Both direction work when using untruncated propositions-as-types.
SigmaLater_laterSigma (A : U) (P : A -> U) (w : (a : A) * |> (P a)) :
    |> ((a : A) * P a) = next [w2 <- w.2] (w.1, w2)
laterSigma_SigmaLater (A : U) (P : A -> U)
        (t : (a' : |> A) -> (a : A) * Id (|> A) a' (next a))
        (w' : |> ((a : A) * P a)) : (a : A) * |> (P a) = let
    a' : |> A = next [w <- w'] w.1
    a : A = (t a').1
    a'_Na : Id (|> A) a' (next a) = (t a').2
    p' : |> [(a : A) <- a'] (P a) = next [w <- w'] w.2
        -- ^ Type annotation is required in [(a : A) <- a']. Otherwise,
        -- gcubical says "inferType: not neutral next k0 w (next w = w').1"
    p : |> (P a) = comp (<i> |> [a <- a'_Na @ i] (P a)) p' []
    in (a, p)

exists (A : U) (P : A -> U) : U = inh ((a : A) * P a)
later1 (A : U) (P : A -> U) (a : A) : U = |> (P a)

-- For truncated logic, the first implication holds ...
existsLater_laterExists (A : U) (P : A -> U) (_ : (a : A) -> prop (P a)) :
        exists A (later1 A P) -> |> (exists A P)
    = inhRec ((a : A) * |> (P a)) (|> (exists A P))
        (laterIsProp (exists A P) (inhIsProp ((a : A) * P a)))
        (\(q : (a : A) * |> (P a)) -> next [q2 <- q.2] inc (q.1, q2))
-- ... but the opposite direction does not seem provable. The first hole is
-- stuck building an argument to t: q is a truncation and comes from q', t is a
-- useless recursion, pP gives a path in P _, and P and A give types. Moreover,
-- to fill the second hole the first one must satisfy P.
laterExists_existsLater (A : U) (P : A -> U) (pP : (a : A) -> prop (P a))
        (t : (a' : |> A) -> inh ((a : A) * Id (|> A) a' (next a)))
        (q' : |> (exists A P)) : exists A (later1 A P) = let
    a' : |> A = next [q <- q'] ?
    in inhRec ((a : A) * Id (|> A) a' (next a)) (exists A (later1 A P))
              (inhIsProp ((a : A) * |> (P a))) (
                \(w : (a : A) * Id (|> A) a' (next a)) ->
                    inc (w.1, comp (<i> |> [a <- w.2 @ i] (P a))
                        (next [q <- q', (a : A) <- a'] ?
                        --  inhRec ((a : A) * P a) (P a) (pP a) ? q
                        ) []
                    )
              ) (t a')
