module dataclocks where

import prelude

fix (A : U) : forall k, (|> k A -> A) -> A
  = [ k ] (\ (f : |> k A -> A) -> f (dfix k A f))

app (A : U) (B : A -> U) : forall k, (F : |> k ((x : A) -> B x)) (X : |> k A) -> |> k [ (x : A) <- X ] (B x)
 = [ k ] \ (F : |> k ((x : A) -> B x)) (X : |> k A) -> next k [ (x : A) <- X, (f : ((x : A) -> B x)) <- F ] (f x) []

app' (A : U) (B : U) : forall k, (F : |> k ((x : A) -> B)) (X : |> k A) -> |> k B
 = app A (\ (_ : A) -> B)

dfixeq (A : U) : forall k, (f : |> k A -> A) -> IdP (<i> |> k A) (next k (f (dfix k A f))) (dfix k A f)
   = [ k ] \ (f : |> k A -> A) -> <i> next k [] (f (dfix k A f)) [ (i=0) -> (next k (f (dfix k A f))), (i=1) -> (dfix k A f) ]

data gStr (A : U) k = Cons (x : A) (xs : |> k (gStr A $ k))

ghd (A : U) k : (xs : gStr A $ k) -> A
  = split
     Cons x _ -> x

gtl (A : U) k : (xs : gStr A $ k) -> |> k (gStr A $ k)
  = split
     Cons _ xs -> xs

Str (A : U) : U
  = forall k, gStr A $ k

hd (A : U) (xs : Str A) : A
  = ghd A $ k0 (xs $ k0)

tl (A : U) (xs : Str A) : Str A
  = prev k (gtl A $ k (xs $ k))

data Unit = unit

units k : gStr Unit $ k
  = fix (gStr Unit $ k) $ k (\ (r : |> k (gStr Unit $ k)) -> Cons unit r)

test2 : Unit
  = hd Unit (tl Unit (tl Unit units))

test3 : Str Unit
  = (tl Unit (tl Unit units))

data gCoNat k = zero | suc (n : |> k (gCoNat $ k))

CoNat : U
  = forall k, gCoNat $ k

data Maybe (A : U) = nothing | just (x : A)

case (A : U) k (z : A) (s : (|> k (gCoNat $ k)) -> A) : gCoNat $ k -> A
  = split
     zero -> z
     suc n -> s n

case' k (A : gCoNat $ k -> U) (z : A zero) (s : (n : |> k (gCoNat $ k)) -> A (suc n)) : (n : gCoNat $ k) -> A n
  = split
     zero -> z
     suc n -> s n

-- uncons (x : CoNat) k : Maybe CoNat
--   = case (Maybe CoNat) $ k nothing (\ (n : |> k (gCoNat $ k)) -> just ([ k' ] (suc ?))) (x $ k)

data CoVec (A : U) k (n : gCoNat $ k) = con (_ : case U $ k Unit (\ (n : |> k (gCoNat $ k)) -> (_ : A ) * |> k [ (x : gCoNat $ k) <- n ] (CoVec A $ k x)) n)

uncon (A : U) (B : U) k (n : gCoNat $ k) (f : case U $ k Unit (\ (n : |> k (gCoNat $ k)) -> (_ : A ) * |> k [ (x : gCoNat $ k) <- n ] (CoVec A $ k x)) n -> B) :
    CoVec A $ k n -> B
  = split
     con x -> f x

CoVec' (A : U) k (n : gCoNat $ k) : U
  = case U $ k Unit (\ (n : |> k (gCoNat $ k)) -> (_ : A ) * |> k [ (x : gCoNat $ k) <- n ] (CoVec A $ k x)) n

uncon' (A : U) k (n : gCoNat $ k) (B : CoVec A $ k n -> U) (f : (v : CoVec' A $ k n) -> B (con v)) :
    (v : CoVec A $ k n) -> B v
  = split
     con x -> f x

-- data CoVec' (A : U) k (n : gCoNat $ k) = nil (_ : IdP (<_> gCoNat $ k) n zero)
--                                       | cons (m : |> k gCoNat $ k) (x : A) (_ : IdP (<_> gCoNat $ k) (suc m) n)
--                                              (xs : |> k [ (m' : gCoNat $ k) <- m ] CoVec' A $ k m')

unitsv k : (n : gCoNat $ k) -> CoVec Unit $ k n
  = fix ((n : gCoNat $ k) -> CoVec Unit $ k n) $ k
      (\ (phi : |> k ((n : gCoNat $ k) -> CoVec Unit $ k n)) (n : gCoNat $ k) ->
        case' $ k (CoVec Unit $ k) (con unit)
            (\ (m : |> k (gCoNat $ k)) -> con (unit , app (gCoNat $ k) (\ (x : gCoNat $ k) -> CoVec Unit $ k x) $ k phi m)) n)

dmap (A B : U) (f : A -> B) k : |> k ((n : gCoNat $ k) -> CoVec A $ k n -> CoVec B $ k n)
  = dfix k ((n : gCoNat $ k) -> CoVec A $ k n -> CoVec B $ k n) (\ (phi : |> k ((n : gCoNat $ k) -> CoVec A $ k n -> CoVec B $ k n)) ->
        case' $ k (\ (n : gCoNat $ k) -> CoVec A $ k n -> CoVec B $ k n) (\ (x : CoVec A $ k zero) -> con unit)
                  (\ (n : |> k gCoNat $ k) -> uncon A (CoVec B $ k (suc n)) $ k (suc n)
                        (\ (p : (_ : A) * |> k [ (n' : gCoNat $ k) <- n ] CoVec A $ k n') -> con (f (p.1) ,
                   next k [ (phi' : (n : gCoNat $ k) -> CoVec A $ k n -> CoVec B $ k n) <- phi, (n' : gCoNat $ k) <- n, (xs : CoVec A $ k n') <- p.2 ]
                          (phi' n' xs) []) )))

dmap2 (A B : U) (f : A -> B) k (n : |> k (gCoNat $ k)) (xs : |> k [ (n' : gCoNat $ k) <- n ] CoVec A $ k n') : |> k [ (n' : gCoNat $ k) <- n ] (CoVec B $ k n')
  = next k [ (n' : gCoNat $ k) <- n, (xs' : CoVec A $ k n') <- xs, (f : (n : gCoNat $ k) -> CoVec A $ k n -> CoVec B $ k n) <- dmap A B f $ k ]
           (f n' xs') []


map (A B : U) (f : A -> B) k : (n : gCoNat $ k) -> CoVec A $ k n -> CoVec B $ k n
  = fix ((n : gCoNat $ k) -> CoVec A $ k n -> CoVec B $ k n) $ k (\ (phi : |> k ((n : gCoNat $ k) -> CoVec A $ k n -> CoVec B $ k n)) ->
        case' $ k (\ (n : gCoNat $ k) -> CoVec A $ k n -> CoVec B $ k n) (\ (x : CoVec A $ k zero) -> con unit)
                  (\ (n : |> k gCoNat $ k) -> uncon A (CoVec B $ k (suc n)) $ k (suc n)
                        (\ (p : (_ : A) * |> k [ (n' : gCoNat $ k) <- n ] CoVec A $ k n') -> con (f (p.1) ,
                   next k [ (phi' : (n : gCoNat $ k) -> CoVec A $ k n -> CoVec B $ k n) <- phi, (n' : gCoNat $ k) <- n, (xs : CoVec A $ k n') <- p.2 ]
                          (phi' n' xs) []) )))


mapComp' (A B C : U) (f : A -> B) (g : B -> C) k (phi : |> k ((n : gCoNat $ k) (xs : CoVec A $ k n) ->
        Id (CoVec C $ k n) (map B C g $ k n (map A B f $ k n xs)) (map A C (\ (x : A) -> g (f x)) $ k n xs)))
      : (n : gCoNat $ k) (xs : CoVec A $ k n) ->
        Id (CoVec C $ k n) (map B C g $ k n (map A B f $ k n xs)) (map A C (\ (x : A) -> g (f x)) $ k n xs)
  = split
      zero -> \ (xs : CoVec A $ k zero) -> <i> con unit
      suc n ->
        uncon' A $ k (suc n) (\ (xs : CoVec A $ k (suc n)) ->
              Id (CoVec C $ k (suc n)) (map B C g $ k (suc n) (map A B f $ k (suc n) xs)) (map A C (\ (x : A) -> g (f x)) $ k (suc n) xs))

            (\ (xs : CoVec' A $ k (suc n)) -> <i> con (g (f xs.1) , next k
              [ (phi' : (n : gCoNat $ k) -> (xs : CoVec A $ k n) ->
                 Id (CoVec C $ k n) (map B C g $ k n (map A B f $ k n xs))
                               (map A C (\ (x : A) -> g (f x)) $ k n xs)) <- phi
              , (n' : gCoNat $ k) <- n
              , (xs' : CoVec A $ k n') <- xs.2
              ]
               (phi' n' xs' @ i) [ (i=0) -> dmap2 B C g $ k n (dmap2 A B f $ k n (xs.2))
                                 , (i=1) -> dmap2 A C (\ (x : A) -> g (f x)) $ k n (xs.2) ]))

data Nat = ze | su (n : Nat)

nats : Str Nat
  = [ k ] fix (Nat -> gStr Nat $ k) $ k (\ (xs : |> k (Nat -> gStr Nat $ k)) (n : Nat) -> 
                       Cons n (next k [ (xs' : Nat -> gStr Nat $ k) <- xs ] (xs' (su n)) [])) ze

everyother (A : U) (xs : Str A) : Str A
  = [ k ] fix (Str A -> gStr A $ k) $ k (\ (phi : |> k (Str A -> gStr A $ k)) (xs : Str A) ->
            Cons (hd A xs) (next k [ (phi' : Str A -> gStr A $ k) <- phi ] (phi' (tl A (tl A xs))) [])) xs


eoProp (A : U) (xs : Str A) : Id A (hd A (tl A (everyother A xs))) (hd A (tl A (tl A xs)))
  = <i> (hd A (tl A (tl A xs)))

forallFresh (A : U) (t : forall k, A) k k' : Id A (t $ k) (t $ k')
  = <i> t $ k0

wrong k k' : Id U (gCoNat $ k) (gCoNat $ k')
  = forallFresh U gCoNat $ k $ k'

-- rightlyFails k k' : Id U (gCoNat $ k) (gCoNat $ k')
--   = <i> gCoNat $ k0

cze : CoNat
  = [ k ] zero

csu (n : CoNat) : CoNat
  = [ k ] (suc (next k (n $ k)))

data Bool = true | false

If (A B : U) : Bool -> U
  = split
      true -> A
      false -> B

if' (P : Bool -> U) (x : P true) (y : P false) : (b : Bool) -> P b
  = split
      true -> x
      false -> y

Plus (A B : U) : U
  = (b : Bool) * If A B b

comIf (A B : forall k, U) : (b : Bool) -> (forall k, If (A $ k) (B $ k) b) -> If (forall k, A $ k) (forall k, B $ k) b
  = split
      true -> \ (x : forall k, A $ k) -> x
      false -> \ (x : forall k, B $ k) -> x

comPlus' (A B : forall k, U) (z1 : forall k, Bool) (z2 : forall k, If (A $ k) (B $ k) (z1 $ k)) : Plus (forall k, A $ k) (forall k, B $ k)
 = ((z1 $ k0) , comIf A B (z1 $ k0) ([ k ] (z2 $ k)))

comPlus (A B : forall k, U) (z : forall k, Plus (A $ k) (B $ k)) : Plus (forall k, A $ k) (forall k, B $ k)
 = comPlus' A B ([ k ] (z $ k).1) ([ k ] (z $ k).2)

comCoNat' (n : CoNat) : Plus (forall k, Unit) (forall k, |> k gCoNat $ k)
  = comPlus ([ k ] Unit) ([ k ] |> k gCoNat $ k) ([ k ] case (Plus Unit (|> k gCoNat $ k)) $ k (true , unit) (\ (m : |> k gCoNat $ k) -> (false , m)) (n $ k))

comCoNat (n : CoNat) : Maybe CoNat
  = force q.1 q.2
   where
    q : Plus (forall k, Unit) (forall k, |> k gCoNat $ k)
      = comCoNat' n
    force : (b : Bool) -> If (forall k, Unit) (forall k, |> k gCoNat $ k) b -> Maybe CoNat
      = split
          true -> (\ (x : forall k, Unit) -> nothing)
          false -> (\ (x : forall k, |> k gCoNat $ k) -> just (prev k (x $ k)))

comcze : Id (Maybe CoNat) (comCoNat cze) nothing
  = <i> nothing

comcsu (n : CoNat) : Id (Maybe CoNat) (comCoNat (csu n)) (just n)
  = <i> just n

