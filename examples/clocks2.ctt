module clocks2 where

import prelude

later k :|> k U -> U
  = (\ (A : |> k U) -> |> k [ (a : U) <- A ] a)

app (A : U) (B : A -> U) : forall k, (F : |> k ((x : A) -> B x)) (X : |> k A) -> |> k [ (x : A) <- X ] (B x)
 = [ k ] \ (F : |> k ((x : A) -> B x)) (X : |> k A) -> next k [ (x : A) <- X, (f : ((x : A) -> B x)) <- F ] (f x) []

app' (A : U) (B : U) : forall k, (F : |> k ((x : A) -> B)) (X : |> k A) -> |> k B
 = app A (\ (_ : A) -> B)

fix' (A : U) : forall k, (|> k A -> A) -> A
  = [ k ] (\ (f : |> k A -> A) -> f (dfix k A f))

data Unit = unit

fl (t : forall k, U) : U
 = forall k, t $ k

StreamF (A : U) k (Stream' : |> k U) : U
  = ((a : A) * later $ k Stream')

data Stream (A : U) k = Cons (xs : fix k Stream' U (StreamF A $ k Stream'))

deCons (A : U) k : Stream A $ k -> fix k Stream' U (StreamF A $ k Stream')
 = split
    Cons x -> x

dfixeq (A : U) : forall k, (f : |> k A -> A) -> IdP (<i> |> k A) (next k (f (dfix k A f))) (dfix k A f)
   = [ k ] \ (f : |> k A -> A) ->
     <i> next k [] (f (dfix k A f))
                   [ (i=0) -> (next k (f (dfix k A f))),
		     (i=1) -> (dfix k A f) ]

dfixeq' (A : U) k (f : |> k A -> A) : IdP (<_> |> k A) (next k (fix k phi A (f phi))) (dfix k A f)
  =  <i> next k [] (f (dfix k A f))
                   [ (i=0) -> (next k (f (dfix k A f))),
		     (i=1) -> (dfix k A f) ]

fold : forall k, (f : |> k U -> U) -> |> k (fix' U $ k f) -> later $ k (dfix k U f)
 = [ k ] \ (f : |> k U -> U) (x : |> k (fix' U $ k f)) -> transport (<i> later $ k (dfixeq U $ k f @ i)) x

unfold : forall k, (f : |> k U -> U) -> later $ k (dfix k U f) -> |> k (fix' U $ k f)
 = [ k ] \ (f : |> k U -> U) (x : later $ k (dfix k U f)) -> transport (<i> later $ k (dfixeq U $ k f @ -i)) x

-- dfixeq (A : U) : forall k, (f : |> k A -> A) -> IdP (<i> |> k A) (next k (f (dfix k A f))) (dfix k A f)
--    = [ k ] \ (f : |> k A -> A) -> <i> next k [] (f (dfix k A f)) [ (i=0) -> (next k (f (dfix k A f))), (i=1) -> (dfix k A f) ]

ifold (A : U) : forall k, (f : |> k (A -> U) -> A -> U) -> (x : A) 
                          -> |> k (fix' (A -> U) $ k f x) 
                          -> later $ k (next k [ (f' : A -> U) <- (dfix k (A -> U) f) ] (f' x) [])
 = [ k ] \ (f : |> k (A -> U) -> (A -> U)) (x : A) (y : |> k (fix' (A -> U) $ k f x)) -> transport 
          (<i> later $ k (next k [ (f' : A -> U) <- (dfixeq (A -> U) $ k f @ i) ] (f' x) [])) y 

ifold2 (A : U) k (f : |> k (A -> U) -> A -> U) (x : |> k A)
                 (y : |> k [ x' <- x ] (fix' (A -> U) $ k f x'))
                 : |> k [ f' <- dfix k (A -> U) f, x' <- x] (f' x')
 = transport (<i> later $ k (app' A U $ k (dfixeq (A -> U) $ k f @ i) x)) y

iunfold (A : U) : forall k, (f : |> k (A -> U) -> A -> U) -> (x : A)
                          -> later $ k (next k [ (f' : A -> U) <- (dfix k (A -> U) f) ] (f' x) [])
                          -> |> k (fix' (A -> U) $ k f x)
 = [ k ] \ (f : |> k (A -> U) -> (A -> U)) (x : A) (y : later $ k (next k [ (f' : A -> U) <- (dfix k (A -> U) f) ] (f' x) [])) -> transport 
          (<i> later $ k (next k [ (f' : A -> U) <- (dfixeq (A -> U) $ k f @ -i) ] (f' x) [])) y

 -- transport (<i> later $ k (dfixeq (A -> U) $ k f @ i)) x

-- unifold : forall k, (f : |> k U -> U) -> later $ k (dfix k U f) -> |> k (fix' U $ k f)
--  = [ k ] \ (f : |> k U -> U) (x : later $ k (dfix k U f)) -> transport (<i> later $ k (dfixeq U $ k f @ -i)) x

unfoldfold k (f : |> k U -> U) (x : |> k (fix' U $ k f)) : IdP (<i> |> k (fix' U $ k f)) x (unfold $ k f (fold $ k f x))
  = undefined -- <i> next k [ x' <- x ] x' [ (i=0) -> x , (i=1) -> (unfold $ k f (fold $ k f x)) ]

ghd (A : U) k : (Stream A $ k) -> A
  = split 
     Cons xs -> xs.1

gtl (A : U) k : (Stream A $ k) -> |> k (Stream A $ k)
  = split
      Cons x -> next k [ z <- (unfold $ k (StreamF A $ k) (x.2)) ] (Cons z) []

tail (A : U) (xs : forall k, (Stream A $ k)) : (forall k, (Stream A $ k))
  = prev k (gtl A $ k (xs $ k))

head (A : U) (xs : forall k, Stream A $ k) : forall k, A
  = [ k ] ghd A $ k (xs $ k)

units : forall k, Stream Unit $ k
  = [ k ] fix k units (Stream Unit $ k) (Cons (unit , (fold $ k (StreamF Unit $ k) (next k [ units' <- units ] (deCons Unit $ k units') [])  )))

snd : forall k, Unit
 = head Unit (tail Unit (tail Unit units))

trd : forall k, Unit
 = head Unit (tail Unit (tail Unit (tail Unit units)))

liftPF (A : U) (P : A -> U) k (liftP : |> k (Stream A $ k -> U)) (xs : Stream A $ k) : U
  = (_ : P (ghd A $ k xs)) *
              later $ k (app' (Stream A $ k) U $ k liftP (gtl A $ k xs))

liftP (A : U) (P : A -> U) : forall k, Stream A $ k -> U
 = [ k ] fix k liftP (Stream A $ k -> U) (liftPF A P $ k liftP)

liftLemma (A : U) (P : A -> U) (p : (x : A) -> P x) : forall k, (xs : Stream A $ k) -> liftP A P $ k xs
  = [ k ] fix k phi ((xs : Stream A $ k) -> liftP A P $ k xs) (\ (xs : Stream A $ k) ->
          ( p (ghd A $ k xs)
          , ifold2 (Stream A $ k) $ k (liftPF A P $ k) (gtl A $ k xs) (next k [ phi' <- phi, xs' <- gtl A $ k xs ] (phi' xs') [])
          ))



