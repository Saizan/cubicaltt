module thetafix where

import clocks

FooF (A : U) k (Foo : |> k U) : U
  = (((|> k [ x <- Foo ] x) -> ((|> k A) -> A) -> A))

Foo (A : U) k : U
  = (FooF A $ k (dfix k U (FooF A $ k)))


foldFoo (A : U) k (f : ((|> k (Foo A $ k)) -> ((|> k A) -> A) -> A)) : (Foo A $ k)
  = (\ (a : |> k [ x <- (dfix k U (FooF A $ k)) ] x) -> f (unfold $ k (FooF A $ k) a))

unfoldFoo (A : U) k (f : Foo A $ k) (a : |> k (Foo A $ k)) : ((|> k A) -> A) -> A
  = f (fold $ k (FooF A $ k) a)

later k :|> k U -> U
  = (\ (A : |> k U) -> |> k [ (a : U) <- A ] a)

app (A : U) (B : A -> U) : forall k, (F : |> k ((x : A) -> B x)) (X : |> k A) -> |> k [ (x : A) <- X ] (B x)
 = [ k ] \ (F : |> k ((x : A) -> B x)) (X : |> k A) -> next k [ (x : A) <- X, (f : ((x : A) -> B x)) <- F ] (f x) []

app' (A : U) (B : U) : forall k, (F : |> k ((x : A) -> B)) (X : |> k A) -> |> k B
 = app A (\ (_ : A) -> B)

theta1 (A : U) k : (y : |> k (Foo A $ k)) -> |> k ((|> k (Foo A $ k)) -> ((|> k A) -> A) -> A)
  = \ (y : |> k (Foo A $ k)) ->
      app' (Foo A $ k) ((|> k (Foo A $ k)) -> ((|> k A) -> A) -> A) $ k (next k [] (unfoldFoo A $ k) []) y

theta2 (A : U) k : (|> k ((|> k (Foo A $ k)) -> ((|> k A) -> A) -> A)) -> (|> k (Foo A $ k)) -> |> k (((|> k A) -> A) -> A)
  = \ (f : (|> k ((|> k (Foo A $ k)) -> ((|> k A) -> A) -> A))) (y : (|> k (Foo A $ k))) ->
    app' (|> k (Foo A $ k)) (((|> k A) -> A) -> A) $ k f (next k [] y [])

theta3 (A : U) k : (p : |> k (((|> k A) -> A) -> A)) -> (f : ((|> k A) -> A)) -> |> k A
  = \ (p : |> k (((|> k A) -> A) -> A)) (f : ((|> k A) -> A)) ->
    app' ((|> k A) -> A) A $ k p (next k [] f [])

theta (A : U) k : (_ : |> k (Foo A $ k)) -> ((|> k A) -> A) -> A
   = \ (y : |> k (Foo A $ k)) -> \ (f : (|> k A) -> A) ->
     f (theta3 A $ k (theta2 A $ k (theta1 A $ k y) y) f)

deffix (A : U) k : (|> k A -> A) -> A
   = theta A $ k (next k [] (foldFoo A $ k (theta A $ k)) [])

data Unit = unit

data gStr (A : U) k = Cons (x : A) (xs : |> k (gStr A $ k))

gtl (A : U) k : gStr A $ k -> |> k (gStr A $ k)
 = split
     Cons x xs -> xs

zeros k : gStr Unit $ k
    =  deffix (gStr Unit $ k) $ k (\ (xs : |> k (gStr Unit $ k)) -> (Cons unit xs))
