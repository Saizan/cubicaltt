module guard where

F (A : U) (X : |> U) : U
 = (_  : A) * later X

head (A : U) (X : |> U) (x : F A X) : A
 = x.1
tail (A : U) (X : |> U) (x : F A X) : later X
 = x.2

cons (A : U) (X : |> U) (a : A) (x : later X) : F A X
 = (a , x)

foo (A : U) (t : |> A) : |> [ (x : A) <- t ] A
 = next [ (x : A) <- t ] x

foo' (A : U) (t : |> A) : |> [ (x : A) <- t ] A
 = t

fooeq (A : U) (t : |> A) : IdP (<i> |> A) (foo A t) (foo' A t)
  = <i> t

bar (A : U) (t : |> A) (u : |> A) : |> [(x : A) <- t, (y : A) <- u] A
 = next [(x : A) <- t, (y : A) <- u] x

bar' (A : U) (t : |> A) (u : |> A) : |> [(x : A) <- t, (y : A) <- u] A
 = next [(y : A) <- u, (x : A) <- t] x
 
bar'' (A : U) (t : |> A) (u : |> A) : |> [(x : A) <- t, (y : A) <- u] A
 = t

bar''' (A : U) (t : |> A) (u : |> A) : |> [(x : A) <- t, (y : A) <- u] A
 = u

bareq (A : U) (t : |> A) (u : |> A) : IdP (<i> |> A) (bar A t u) (bar' A t u)
 = <i> t

baz (A : U) (B : A -> U) (t : |> A) (u : |> [(x : A) <- t] B x) : |> [(x : A) <- t, (y : B x) <- u] A
   = next [(x : A) <- t, (y : B x) <- u] x
-- = next [(y : B x) <- u, (x : A) <- t] x  -- this does not resolve (which is good)

