module gctt_data where

-- In this file we define GR data types using `data` instead of using
-- fixed points on universes.

{-     Prerequisites
--------------------------- -}

-- From prelude:

Id (A : U) (a0 a1 : A) : U = IdP (<i> A) a0 a1

-- From nat:

data nat = Z | S (n : nat)
  

{-     Fixed point lemmata
------------------------------- -}

dfix' (A : U) (f : |> A -> A) : |> A
 = dfix k0 A f

fix' (A : U) (f : |> A -> A) : A
 = f (dfix k0 A f)

-- dfix *is* a fixed point operator
dfixeq (A : U) (f : |> A -> A) : Id (|> A) (dfix' A f) (next (f (dfix' A f)))
 = <i> dfix k0 A f [(i=1)]

fixeq (A : U) (f : |> A -> A) : Id A (fix' A f) (f (next (fix' A f)))
 = <i> f (dfixeq A f @ i)

{-       Streams
------------------------- -}

data Str = Cons (n : nat) (ns : |> Str)

hd : Str -> nat
 = split
     Cons n _ -> n

tl : Str -> |> Str
 = split
     Cons _ ns -> ns

-- Cons (n : nat) (s : |> Str) : Str
--  = (n ,  foldStr s)

zeros : Str
 = fix (Cons Z zeros)

-- Eta for streams. `etaStr` is `pÎ·` from the gDTT paper:

etaStr' : (s : Str) -> IdP (<_> Str) s (Cons (hd s) (tl s))
 = split
     Cons n ns -> <i> Cons n ns

etaStr (s1 s2 : Str)
       (hdp : Id nat (hd s1) (hd s2))
       (tlp : Id (|> Str) (tl s1) (tl s2))
       : Id Str s1 s2
 = <i> comp (<_> Str)
            (Cons (hdp @ i) (tlp @ i))
            [(i=0) -> <j> etaStr' s1 @ -j
            ,(i=1) -> <j> etaStr' s2 @ -j]

 
{-   Example:  zipWith preserves commutativity
---------------------------------------------------- -}

-- -- It will be nice to be able to directly refer to the function which zipWith is
-- -- a fixed point of:

zwF (f : nat -> nat -> nat) (rec : |> (Str -> Str -> Str)) : Str -> Str -> Str
 = (\ (s1 s2 : Str) ->
      (Cons (f (hd s1) (hd s2))
      	    (next
	    	  [ zipWith' <- rec
		  , s1' <- tl s1
		  , s2' <- tl s2]
		  zipWith' s1' s2')))

zipWith (f : nat -> nat -> nat) : Str -> Str -> Str
 = fix (\ (s1 s2 : Str) ->
          (Cons (f (hd s1) (hd s2))
                (next [ zipWith' <- zipWith
                      , s1'      <- tl s1
                      , s2'      <- tl s2 ]
                      zipWith' s1' s2')))

-- zipWith is equal to its own unfolding
zipWithEq (f : nat -> nat -> nat)
 : Id (Str -> Str -> Str)
      (zwF f (next (zipWith  f)))
      (zipWith f)
 = <i> fixeq (Str -> Str -> Str) (zwF f) @ -i

-- Commutativity property
comm (f : nat -> nat -> nat) : U
 = (m n : nat) -> Id nat (f m n) (f n m)

-- zipWith preserves commutativity
zipWithPreservesComm (f : nat -> nat -> nat) (p : comm f)
 : (s1 s2 : Str) -> Id Str (zipWith f s1 s2) (zipWith f s2 s1)
 = fix (\ (s1 s2 : Str) ->
          etaStr (zipWith f s1 s2)
                 (zipWith f s2 s1)
                 (p (hd s1) (hd s2))
                 (<i> comp (<_> |> Str)
                           (next [ phi <- zipWithPreservesComm
                                 , s1' <- tl s1
                                 , s2' <- tl s2 ]
                                 phi s1' s2' @ i)
                           [(i=0) -> <j> tl (zipWithEq f @ j s1 s2)
                           ,(i=1) -> <j> tl (zipWithEq f @ j s2 s1)]))
   


{-   Example: CoNats
  --------------------- -}

data Conat = Z | S (n : |> Conat)

omega : Conat
 = fix (S omega)
