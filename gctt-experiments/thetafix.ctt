module thetafix where

later k :|> k U -> U
  = (\ (A : |> k U) -> |> k [ (a : U) <- A ] a)

fix' (A : U) : forall k, (|> k A -> A) -> A
  = [ k ] (\ (f : |> k A -> A) -> f (dfix k A f))

dfixeq k (A : U) (f : |> k A -> A) : IdP (<i> |> k A) (next k (f (dfix k A f))) (dfix k A f)
   = <i> dfix k A f [(i=0)]

fold k (f : |> k U -> U) (x : |> k (fix' U $ k f)) : later $ k (dfix k U f)
 = transport (<i> later $ k (dfixeq $ k U f @ i)) x

unfold k  (f : |> k U -> U) (x : later $ k (dfix k U f)) : |> k (fix' U $ k f)
 = transport (<i> later $ k (dfixeq $ k U f @ -i)) x



FooF (A : U) k (Foo : |> k U) : U
  = (((|> k [ x <- Foo ] x) -> ((|> k A) -> A) -> A))

Foo (A : U) k : U
  = (FooF A $ k (dfix k U (FooF A $ k)))



foldFoo (A : U) k (f : ((|> k (Foo A $ k)) -> ((|> k A) -> A) -> A)) : (Foo A $ k)
  = (\ (a : |> k [ x <- (dfix k U (FooF A $ k)) ] x) -> f (unfold $ k (FooF A $ k) a))

unfoldFoo (A : U) k (f : Foo A $ k) (a : |> k (Foo A $ k)) : ((|> k A) -> A) -> A
  = f (fold $ k (FooF A $ k) a)

later k :|> k U -> U
  = (\ (A : |> k U) -> |> k [ (a : U) <- A ] a)

app (A : U) (B : A -> U) : forall k, (F : |> k ((x : A) -> B x)) (X : |> k A) -> |> k [ (x : A) <- X ] (B x)
 = [ k ] \ (F : |> k ((x : A) -> B x)) (X : |> k A) -> next k [ (x : A) <- X, (f : ((x : A) -> B x)) <- F ] (f x)

app' (A : U) (B : U) : forall k, (F : |> k ((x : A) -> B)) (X : |> k A) -> |> k B
 = app A (\ (_ : A) -> B)

theta1 (A : U) k : (y : |> k (Foo A $ k)) -> |> k ((|> k (Foo A $ k)) -> ((|> k A) -> A) -> A)
  = \ (y : |> k (Foo A $ k)) ->
      app' (Foo A $ k) ((|> k (Foo A $ k)) -> ((|> k A) -> A) -> A) $ k (next k [] (unfoldFoo A $ k)) y

theta2 (A : U) k : (|> k ((|> k (Foo A $ k)) -> ((|> k A) -> A) -> A)) -> (|> k (Foo A $ k)) -> |> k (((|> k A) -> A) -> A)
  = \ (f : (|> k ((|> k (Foo A $ k)) -> ((|> k A) -> A) -> A))) (y : (|> k (Foo A $ k))) ->
    app' (|> k (Foo A $ k)) (((|> k A) -> A) -> A) $ k f (next k [] y )

theta3 (A : U) k : (p : |> k (((|> k A) -> A) -> A)) -> (f : ((|> k A) -> A)) -> |> k A
  = \ (p : |> k (((|> k A) -> A) -> A)) (f : ((|> k A) -> A)) ->
    app' ((|> k A) -> A) A $ k p (next k [] f )

theta (A : U) k : (_ : |> k (Foo A $ k)) -> ((|> k A) -> A) -> A
   = \ (y : |> k (Foo A $ k)) -> \ (f : (|> k A) -> A) ->
     f (theta3 A $ k (theta2 A $ k (theta1 A $ k y) y) f)

deffix (A : U) k : (|> k A -> A) -> A
   = theta A $ k (next k [] (foldFoo A $ k (theta A $ k)))

data Unit = unit

data gStr (A : U) k = Cons (x : A) (xs : |> k (gStr A $ k))

gtl (A : U) k : gStr A $ k -> |> k (gStr A $ k)
 = split
     Cons x xs -> xs

ghd (A : U) k : gStr A $ k -> A
 = split
     Cons x _ -> x

hd (A : U) (s : forall k, gStr A $ k) : A
 = ghd A $ k0 (s $ k0)

tl (A : U) (s : forall k, gStr A $ k) : forall k, gStr A $ k
 = prev k (gtl A $ k (s $ k))

zeros k : gStr Unit $ k
    =  deffix (gStr Unit $ k) $ k (\ (xs : |> k (gStr Unit $ k)) -> (Cons unit xs))

test k : |> k |> k (|> k  Unit)
 = next k [(ys : gStr Unit $ k) <- gtl Unit $ k (zeros $ k)]
  (next k [(xs : gStr Unit $ k) <- gtl Unit $ k ys]
  (next k [(zs : gStr Unit $ k) <- gtl Unit $ k xs]
     	   (ghd Unit $ k zs)))

test2 : Unit
 = hd Unit (tl Unit (tl Unit (tl Unit zeros)))

zeros' : forall k, gStr Unit $ k
  = zeros
